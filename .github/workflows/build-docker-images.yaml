name: Build Docker Images
run-name: Build Docker Images
# This workflow builds OSS/Community Edition Teleport Docker images following
# the official build process documented in README.md. It uses the dockerized
# build approach (make -C build.assets release) and explicitly builds
# OSS packages (oss-deb) which are licensed under the modified Apache 2.0
# license (build.assets/LICENSE-community).

on:
  workflow_dispatch:

jobs:
  build-docker-images:
    name: Build Docker Images
    runs-on: self-hosted

    permissions:
      contents: read

    steps:
      - name: Checkout Teleport
        uses: actions/checkout@v6

      - name: Install Go
        run: |
          set -e
          echo "Checking for Go..."
          if command -v go &> /dev/null; then
            echo "Go is already installed: $(go version)"
          else
            echo "Go not found, installing..."
            GO_VERSION=$(cd build.assets && make -s print-go-version 2>/dev/null | sed 's/go//' || echo "1.24.6")
            echo "Installing Go ${GO_VERSION}..."
            curl -fsSL "https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz" -o /tmp/go.tar.gz
            sudo rm -rf /usr/local/go
            sudo tar -C /usr/local -xzf /tmp/go.tar.gz
            echo "export PATH=/usr/local/go/bin:\$PATH" | sudo tee -a /etc/profile.d/go.sh
            export PATH=/usr/local/go/bin:$PATH
            echo "Verifying Go installation..."
            /usr/local/go/bin/go version || (echo "Go installation failed" && exit 1)
          fi
          # Ensure Go is in PATH for subsequent steps
          echo "/usr/local/go/bin" >> $GITHUB_PATH

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@b5ca514318bd6ebac0fb2aedd5d36ec1b5c232a2 # v3.10.0
        with:
          driver: docker

      - name: Get version
        id: version
        run: |
          VERSION=$(grep '^VERSION=' Makefile | cut -d= -f2 | tr -d ' ')
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Get architecture
        id: arch
        run: |
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then
            ARCH="amd64"
          fi
          echo "arch=${ARCH}" >> $GITHUB_OUTPUT

      - name: Build buildbox-centos7-assets (from source for licensing)
        run: |
          cd build.assets
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then ARCH="amd64"; fi
          RUNNER_UID=$(id -u)
          RUNNER_GID=$(id -g)
          if [ "$RUNNER_UID" = "0" ]; then
            RUNNER_UID=1000
            RUNNER_GID=1000
          fi
          # Buildbox images are build environments - they don't contain our code.
          # We can use cache for them. Our code is built in the "Build release" step.
          # Try to use existing image first (may be cached or pre-built)
          BUILDBOX_CENTOS7_ASSETS="ghcr.io/gravitational/teleport-buildbox-centos7-assets:teleport18-${ARCH}"
          if docker images --format "{{.Repository}}:{{.Tag}}" | grep -q "^${BUILDBOX_CENTOS7_ASSETS}$" || docker pull $BUILDBOX_CENTOS7_ASSETS 2>/dev/null; then
            echo "Using existing buildbox-centos7-assets image"
          else
            echo "Building buildbox-centos7-assets from source..."
            echo "Note: CentOS 7 is EOL - some repositories may be unavailable."
            echo "If build fails, you may need to use a pre-built image or update the Dockerfile."
            # Use Makefile target - it may use cache or handle errors better
            make build-centos7-assets ARCH=$ARCH UID=$RUNNER_UID GID=$RUNNER_GID
          fi

      - name: Build buildbox-centos7 (from source for licensing)
        run: |
          cd build.assets
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then ARCH="amd64"; fi
          RUNNER_UID=$(id -u)
          RUNNER_GID=$(id -g)
          if [ "$RUNNER_UID" = "0" ]; then
            RUNNER_UID=1000
            RUNNER_GID=1000
          fi
          # Buildbox images are build environments - they don't contain our code.
          # We can use cache for them. Our code is built in the "Build release" step.
          # Use the Makefile target which handles repository issues better.
          make buildbox-centos7 ARCH=$ARCH UID=$RUNNER_UID GID=$RUNNER_GID

      - name: Build release (following README dockerized build)
        run: |
          cd build.assets
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then ARCH="amd64"; fi
          RUNNER_UID=$(id -u)
          RUNNER_GID=$(id -g)
          if [ "$RUNNER_UID" = "0" ]; then
            RUNNER_UID=1000
            RUNNER_GID=1000
            chown -R $RUNNER_UID:$RUNNER_GID "$(pwd)/.." /tmp/gomodcache /tmp/gocache 2>/dev/null || true
            chmod -R u+w "$(pwd)/.." /tmp/gomodcache /tmp/gocache 2>/dev/null || true
          fi
          mkdir -p /tmp/gocache
          chown -R $RUNNER_UID:$RUNNER_GID /tmp/gocache 2>/dev/null || true
          chmod -R 777 /tmp/gocache 2>/dev/null || true
          # Follow README: make -C build.assets release
          # This uses the locally built buildbox and builds binaries + archive
          export ARCH=$ARCH
          export CI=true
          export GOCACHE=/tmp/gocache
          export GOMODCACHE=/tmp/gomodcache
          make release-centos7 ARCH=$ARCH ADDFLAGS="-buildvcs=false"

      - name: Build .deb package
        run: |
          # Build .deb package directly on host (no Docker-in-Docker needed)
          # The archive is already built by release-centos7 above
          # build-package.sh will use Docker from the host to run the FPM container
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then ARCH="amd64"; fi
          VERSION=$(grep '^VERSION=' Makefile | cut -d= -f2 | tr -d ' ')
          make oss-deb ARCH=$ARCH VERSION=$VERSION

      - name: Copy fetch-debs script
        run: |
          cp build.assets/charts/fetch-debs build/

      - name: Prepare .deb file for Docker build
        run: |
          DEB_FILE=$(find build/ -name "teleport_*.deb" -type f | head -1)
          if [ -z "$DEB_FILE" ]; then
            echo "Error: .deb file not found"
            exit 1
          fi
          EXPECTED_NAME="teleport_${{ steps.version.outputs.version }}_${{ steps.arch.outputs.arch }}.deb"
          if [ "$(basename "$DEB_FILE")" != "$EXPECTED_NAME" ]; then
            cp "$DEB_FILE" "build/$EXPECTED_NAME"
          fi

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Set image tags
        id: tags
        run: |
          TAGS="aazmy/teleport:${{ steps.version.outputs.version }}-${{ steps.arch.outputs.arch }}"
          TAGS="$TAGS,aazmy/teleport:${{ steps.version.outputs.version }}"
          if [ "${{ steps.arch.outputs.arch }}" = "amd64" ]; then
            TAGS="$TAGS,aazmy/teleport:latest"
          fi
          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "Tags: $TAGS"

      - name: Build and push Teleport Docker image
        uses: docker/build-push-action@471d1dc4e07e5cdedd4c2171150001c434f0b7a4 # v6.15.0
        with:
          context: build/
          file: build.assets/charts/Dockerfile-distroless
          push: true
          tags: ${{ steps.tags.outputs.tags }}
          no-cache: true
          build-args: |
            TELEPORT_VERSION=${{ steps.version.outputs.version }}
            TELEPORT_RELEASE_INFIX=
            TARGETARCH=${{ steps.arch.outputs.arch }}
          platforms: linux/${{ steps.arch.outputs.arch }}

      - name: Save Docker image (for artifact backup)
        run: |
          docker pull aazmy/teleport:${{ steps.version.outputs.version }}-${{ steps.arch.outputs.arch }}
          docker save aazmy/teleport:${{ steps.version.outputs.version }}-${{ steps.arch.outputs.arch }} \
            -o build/teleport-image-${{ steps.version.outputs.version }}-${{ steps.arch.outputs.arch }}.tar

      - name: Upload Docker image (backup)
        uses: actions/upload-artifact@v4
        with:
          name: teleport-docker-image
          path: build/teleport-image-*.tar
          if-no-files-found: warn
